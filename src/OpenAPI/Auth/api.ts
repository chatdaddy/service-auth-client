/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Auth & Teams Service
 * Manage Users & Teams
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@chatdaddy.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * @type AuthRequest
 * @export
 */
export type AuthRequest = PasswordAuthRequest | RefreshTokenLoginRequest;

/**
 * Login with Boutir
 * @export
 * @interface BoutirTokenRequest
 */
export interface BoutirTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'type': BoutirTokenRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'password': string;
}

/**
    * @export
    * @enum {string}
    */
export enum BoutirTokenRequestTypeEnum {
    Boutir = 'boutir'
}

/**
 * 
 * @export
 * @interface ExternalTokenPostResponse
 */
export interface ExternalTokenPostResponse {
    /**
     * Was the user just created
     * @type {boolean}
     * @memberof ExternalTokenPostResponse
     */
    'created'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExternalTokenPostResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTokenPostResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTokenPostResponse
     */
    'refresh_token_expiry'?: string;
}
/**
 * 
 * @export
 * @interface ExternalTokenPostResponseAllOf
 */
export interface ExternalTokenPostResponseAllOf {
    /**
     * Was the user just created
     * @type {boolean}
     * @memberof ExternalTokenPostResponseAllOf
     */
    'created'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {Array<Scope>}
     * @memberof InlineObject
     */
    'scopes': Array<Scope>;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'phoneNumber': string;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'content': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof InlineObject2
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    'refresh_token_expiry'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200
     */
    'was_forced'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Team>}
     * @memberof InlineResponse2001
     */
    'teams': Array<Team>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2002
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    'total'?: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof InlineResponse2003
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {NotificationResult}
     * @memberof InlineResponse2004
     */
    'whatsapp': NotificationResult;
    /**
     * 
     * @type {NotificationResult}
     * @memberof InlineResponse2004
     */
    'email': NotificationResult;
}
/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse400
     */
    'statusCode'?: number;
    /**
     * Specific description of the error
     * @type {string}
     * @memberof InlineResponse400
     */
    'error'?: string;
    /**
     * What the error was
     * @type {string}
     * @memberof InlineResponse400
     */
    'message'?: string;
    /**
     * Some extra information about the error
     * @type {object}
     * @memberof InlineResponse400
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface InviteLink
 */
export interface InviteLink {
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    'id': string;
    /**
     * The team it can join
     * @type {string}
     * @memberof InviteLink
     */
    'teamId': string;
    /**
     * User ID of the person who created the link
     * @type {string}
     * @memberof InviteLink
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    'expiresAt': string;
    /**
     * The scopes allowed for the invite link
     * @type {Array<Scope>}
     * @memberof InviteLink
     */
    'scopes': Array<Scope>;
}
/**
 * 
 * @export
 * @interface JWT
 */
export interface JWT {
    /**
     * Binary representation of the scope array
     * @type {string}
     * @memberof JWT
     */
    'scope': string;
    /**
     * 
     * @type {number}
     * @memberof JWT
     */
    'exp': number;
    /**
     * 
     * @type {number}
     * @memberof JWT
     */
    'iat': number;
    /**
     * 
     * @type {JWTUser}
     * @memberof JWT
     */
    'user': JWTUser;
}
/**
 * 
 * @export
 * @interface JWTUser
 */
export interface JWTUser {
    /**
     * 
     * @type {string}
     * @memberof JWTUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof JWTUser
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof JWTUser
     */
    'fullName'?: string;
    /**
     * 
     * @type {number}
     * @memberof JWTUser
     */
    'phoneNumber': number;
}
/**
 * @type NotificationResult
 * @export
 */
export type NotificationResult = boolean | string;

/**
 * 
 * @export
 * @interface NotifyModel
 */
export interface NotifyModel {
    /**
     * 
     * @type {boolean}
     * @memberof NotifyModel
     */
    'whatsapp'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotifyModel
     */
    'email'?: boolean;
}
/**
 * 
 * @export
 * @interface OAuthRequest
 */
export interface OAuthRequest {
    /**
     * The phone number
     * @type {string}
     * @memberof OAuthRequest
     */
    'username': string;
    /**
     * Plaintext password
     * @type {string}
     * @memberof OAuthRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthRequest
     */
    'grant_type'?: OAuthRequestGrantTypeEnum;
    /**
     * Space separated scopes
     * @type {string}
     * @memberof OAuthRequest
     */
    'scope'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OAuthRequestGrantTypeEnum {
    Password = 'password'
}

/**
 * 
 * @export
 * @interface OTP
 */
export interface OTP {
    /**
     * 
     * @type {number}
     * @memberof OTP
     */
    'phoneNumber': number;
    /**
     * 
     * @type {number}
     * @memberof OTP
     */
    'otp'?: number;
    /**
     * 
     * @type {string}
     * @memberof OTP
     */
    'expiresAt': string;
    /**
     * 
     * @type {number}
     * @memberof OTP
     */
    'resendsLeft': number;
}
/**
 * 
 * @export
 * @interface PasswordAuthRequest
 */
export interface PasswordAuthRequest {
    /**
     * 
     * @type {number}
     * @memberof PasswordAuthRequest
     */
    'phoneNumber': number;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordAuthRequest
     */
    'returnRefreshToken'?: boolean;
    /**
     * This will be the base64 encoded SHA256 of the plaintext password
     * @type {string}
     * @memberof PasswordAuthRequest
     */
    'password': string;
    /**
     * The team ID to generate the token for, lastUsedTeam will be used otherwise
     * @type {string}
     * @memberof PasswordAuthRequest
     */
    'teamId'?: string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof PasswordAuthRequest
     */
    'scopes'?: Array<Scope>;
    /**
     * Should logging in with this team ID update the lastUsedTeam for login
     * @type {boolean}
     * @memberof PasswordAuthRequest
     */
    'updateLastUsedTeam'?: boolean;
    /**
     * Force the generation of an access token
     * @type {boolean}
     * @memberof PasswordAuthRequest
     */
    'force'?: boolean;
}
/**
 * A refresh token allows you to generate access tokens to access & update things on ChatDaddy services. A refresh token will expire and become invalidated after 14 days of no activity. 
 * @export
 * @interface RefreshToken
 */
export interface RefreshToken {
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'expiresAt': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenLoginRequest
 */
export interface RefreshTokenLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenLoginRequest
     */
    'refreshToken': string;
    /**
     * The team ID to generate the token for, lastUsedTeam will be used otherwise
     * @type {string}
     * @memberof RefreshTokenLoginRequest
     */
    'teamId': string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof RefreshTokenLoginRequest
     */
    'scopes'?: Array<Scope>;
    /**
     * Should fetching the token of a new team update the lastUsedTeam for login
     * @type {boolean}
     * @memberof RefreshTokenLoginRequest
     */
    'updateLastUsedTeam'?: boolean;
    /**
     * Force the generation of an access token
     * @type {boolean}
     * @memberof RefreshTokenLoginRequest
     */
    'force'?: boolean;
}
/**
 * 
 * @export
 * @interface ResetPassword
 */
export interface ResetPassword {
    /**
     * 
     * @type {string}
     * @memberof ResetPassword
     */
    'password': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum Scope {
    WaState = 'WA_STATE',
    ContactsReadAssigned = 'CONTACTS_READ_ASSIGNED',
    ContactsReadAll = 'CONTACTS_READ_ALL',
    ContactsExportButton = 'CONTACTS_EXPORT_BUTTON',
    ContactsCreate = 'CONTACTS_CREATE',
    ContactsDelete = 'CONTACTS_DELETE',
    ContactsUpdate = 'CONTACTS_UPDATE',
    CampaignsRead = 'CAMPAIGNS_READ',
    CampaignsCreate = 'CAMPAIGNS_CREATE',
    CampaignsDelete = 'CAMPAIGNS_DELETE',
    CampaignsUpdate = 'CAMPAIGNS_UPDATE',
    KeywordRead = 'KEYWORD_READ',
    KeywordCreate = 'KEYWORD_CREATE',
    KeywordDelete = 'KEYWORD_DELETE',
    KeywordUpdate = 'KEYWORD_UPDATE',
    TemplatesRead = 'TEMPLATES_READ',
    TemplatesCreate = 'TEMPLATES_CREATE',
    TemplatesDelete = 'TEMPLATES_DELETE',
    TemplatesUpdate = 'TEMPLATES_UPDATE',
    TagsRead = 'TAGS_READ',
    TagsCreate = 'TAGS_CREATE',
    TagsDelete = 'TAGS_DELETE',
    TokensRead = 'TOKENS_READ',
    TokensDelete = 'TOKENS_DELETE',
    UsersPatch = 'USERS_PATCH',
    ReferralApplyCredit = 'REFERRAL_APPLY_CREDIT',
    TeamUpdate = 'TEAM_UPDATE',
    AccountCreate = 'ACCOUNT_CREATE',
    AccountRead = 'ACCOUNT_READ',
    AccountDelete = 'ACCOUNT_DELETE',
    AccountPatch = 'ACCOUNT_PATCH',
    TeamlinkCreate = 'TEAMLINK_CREATE',
    TeamlinkRead = 'TEAMLINK_READ',
    TeammembersUpdate = 'TEAMMEMBERS_UPDATE',
    TeammembersRead = 'TEAMMEMBERS_READ',
    TeamNotify = 'TEAM_NOTIFY',
    ChatsAccessAll = 'CHATS_ACCESS_ALL',
    ChatsAccessAssigned = 'CHATS_ACCESS_ASSIGNED',
    ChatsDelete = 'CHATS_DELETE',
    MessagesSendToAssigned = 'MESSAGES_SEND_TO_ASSIGNED',
    MessagesSendToAll = 'MESSAGES_SEND_TO_ALL',
    MessagesSchedule = 'MESSAGES_SCHEDULE',
    MessagesDelete = 'MESSAGES_DELETE',
    GroupsCreate = 'GROUPS_CREATE',
    GroupsUpdate = 'GROUPS_UPDATE',
    Notes = 'NOTES',
    NotificationRead = 'NOTIFICATION_READ',
    NotificationCreate = 'NOTIFICATION_CREATE',
    NotificationUpdate = 'NOTIFICATION_UPDATE',
    NotificationDelete = 'NOTIFICATION_DELETE',
    IntegrationsUpdate = 'INTEGRATIONS_UPDATE',
    AdminPanelAccess = 'ADMIN_PANEL_ACCESS',
    PaymentsRead = 'PAYMENTS_READ',
    PaymentsUpdate = 'PAYMENTS_UPDATE',
    WaLiveEvents = 'WA_LIVE_EVENTS',
    ChatdaddyHook = 'CHATDADDY_HOOK'
}

/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'updatedAt': string;
    /**
     * Who created the team
     * @type {string}
     * @memberof Team
     */
    'createdBy'?: string;
    /**
     * 
     * @type {User}
     * @memberof Team
     */
    'creator'?: User;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'name': string;
    /**
     * Is an admin team
     * @type {boolean}
     * @memberof Team
     */
    'isAdmin'?: boolean;
    /**
     * The max scopes allowed
     * @type {Array<Scope>}
     * @memberof Team
     */
    'scopes': Array<Scope>;
    /**
     * 
     * @type {TeamMetadata}
     * @memberof Team
     */
    'metadata': TeamMetadata;
    /**
     * 
     * @type {Array<TeamMember>}
     * @memberof Team
     */
    'members'?: Array<TeamMember>;
    /**
     * 
     * @type {Array<InviteLink>}
     * @memberof Team
     */
    'inviteLinks'?: Array<InviteLink>;
}
/**
 * 
 * @export
 * @interface TeamMember
 */
export interface TeamMember {
    /**
     * 
     * @type {Team}
     * @memberof TeamMember
     */
    'team'?: Team;
    /**
     * 
     * @type {User}
     * @memberof TeamMember
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof TeamMember
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMember
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMember
     */
    'addedAt': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMember
     */
    'addedBy'?: string | null;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof TeamMember
     */
    'scopes': Array<Scope>;
}
/**
 * 
 * @export
 * @interface TeamMetadata
 */
export interface TeamMetadata {
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'companyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'companyEmailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'companyWebsite'?: string;
}
/**
 * 
 * @export
 * @interface TeamPatchRequest
 */
export interface TeamPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof TeamPatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {TeamMetadata}
     * @memberof TeamPatchRequest
     */
    'metadata'?: TeamMetadata;
    /**
     * 
     * @type {Array<TeamPatchRequestMembers>}
     * @memberof TeamPatchRequest
     */
    'members'?: Array<TeamPatchRequestMembers>;
    /**
     * 
     * @type {Array<TeamPatchRequestInviteLinks>}
     * @memberof TeamPatchRequest
     */
    'inviteLinks'?: Array<TeamPatchRequestInviteLinks>;
}
/**
 * 
 * @export
 * @interface TeamPatchRequestInviteLinks
 */
export interface TeamPatchRequestInviteLinks {
    /**
     * 
     * @type {string}
     * @memberof TeamPatchRequestInviteLinks
     */
    'id': string;
    /**
     * If set to true, will delete the invite link
     * @type {boolean}
     * @memberof TeamPatchRequestInviteLinks
     */
    'delete'?: boolean;
}
/**
 * 
 * @export
 * @interface TeamPatchRequestMembers
 */
export interface TeamPatchRequestMembers {
    /**
     * 
     * @type {string}
     * @memberof TeamPatchRequestMembers
     */
    'id': string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof TeamPatchRequestMembers
     */
    'scopes'?: Array<Scope>;
    /**
     * If set to true, will delete the team member
     * @type {boolean}
     * @memberof TeamPatchRequestMembers
     */
    'delete'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenPostResponse
 */
export interface TokenPostResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenPostResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenPostResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenPostResponse
     */
    'refresh_token_expiry'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'disabledAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullName': string;
    /**
     * The last used team ID, your refresh token when logging in is generated for this team
     * @type {string}
     * @memberof User
     */
    'lastUsedTeamId'?: string;
    /**
     * Will only contain numbers, no + sign, brackets etc.
     * @type {number}
     * @memberof User
     */
    'phoneNumber': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'emailAddress'?: string | null;
    /**
     * 
     * @type {UserCreateMethod}
     * @memberof User
     */
    'createdByMethod'?: UserCreateMethod;
    /**
     * 
     * @type {NotifyModel}
     * @memberof User
     */
    'notify': NotifyModel;
    /**
     * The referral code used for sign-up
     * @type {string}
     * @memberof User
     */
    'referralCode'?: string | null;
    /**
     * 
     * @type {Array<TeamMember>}
     * @memberof User
     */
    'memberships'?: Array<TeamMember>;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'fullName': string;
    /**
     * Will only contain numbers, no + sign, brackets etc.
     * @type {number}
     * @memberof UserCreate
     */
    'phoneNumber': number;
    /**
     * SHA256 of the plaintext password pls
     * @type {string}
     * @memberof UserCreate
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'emailAddress'?: string | null;
    /**
     * 
     * @type {NotifyModel}
     * @memberof UserCreate
     */
    'notify'?: NotifyModel;
    /**
     * Sign up with a referral code
     * @type {string}
     * @memberof UserCreate
     */
    'referralCode'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum UserCreateMethod {
    AdminPanel = 'admin-panel',
    Otp = 'otp',
    Boutir = 'boutir',
    InstantReg = 'instant-reg'
}

/**
 * 
 * @export
 * @interface UserPatch
 */
export interface UserPatch {
    /**
     * 
     * @type {string}
     * @memberof UserPatch
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPatch
     */
    'emailAddress'?: string | null;
    /**
     * 
     * @type {NotifyModel}
     * @memberof UserPatch
     */
    'notify'?: NotifyModel;
    /**
     * Phone number. Only admin access can modify
     * @type {number}
     * @memberof UserPatch
     */
    'phoneNumber'?: number;
    /**
     * new password. Only admin access can modify
     * @type {string}
     * @memberof UserPatch
     */
    'password'?: string;
}

/**
 * InviteLinksApi - axios parameter creator
 * @export
 */
export const InviteLinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get info about an invite link
         * @param {string} id the invite link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('inviteLinksGet', 'id', id)
            const localVarPath = `/invite-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To generate an invite link for a specific set of scopes, you must also have the same set of scopes.  Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself.  This is done for obvious security concerns. 
         * @summary Create an invite link for the team
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksPost: async (inlineObject?: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invite-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEAMLINK_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InviteLinksApi - functional programming interface
 * @export
 */
export const InviteLinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InviteLinksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get info about an invite link
         * @param {string} id the invite link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteLinksGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteLinksGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To generate an invite link for a specific set of scopes, you must also have the same set of scopes.  Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself.  This is done for obvious security concerns. 
         * @summary Create an invite link for the team
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteLinksPost(inlineObject?: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteLinksPost(inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InviteLinksApi - factory interface
 * @export
 */
export const InviteLinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InviteLinksApiFp(configuration)
    return {
        /**
         * 
         * @summary Get info about an invite link
         * @param {string} id the invite link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksGet(id: string, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.inviteLinksGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * To generate an invite link for a specific set of scopes, you must also have the same set of scopes.  Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself.  This is done for obvious security concerns. 
         * @summary Create an invite link for the team
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksPost(inlineObject?: InlineObject, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.inviteLinksPost(inlineObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InviteLinksApi - object-oriented interface
 * @export
 * @class InviteLinksApi
 * @extends {BaseAPI}
 */
export class InviteLinksApi extends BaseAPI {
    /**
     * 
     * @summary Get info about an invite link
     * @param {string} id the invite link ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteLinksApi
     */
    public inviteLinksGet(id: string, options?: AxiosRequestConfig) {
        return InviteLinksApiFp(this.configuration).inviteLinksGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To generate an invite link for a specific set of scopes, you must also have the same set of scopes.  Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself.  This is done for obvious security concerns. 
     * @summary Create an invite link for the team
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteLinksApi
     */
    public inviteLinksPost(inlineObject?: InlineObject, options?: AxiosRequestConfig) {
        return InviteLinksApiFp(this.configuration).inviteLinksPost(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Notify a team member
         * @param {string} userId 
         * @param {boolean} [notifyWhatsApp] Override notify on WhatsApp
         * @param {boolean} [notifyEmail] Override notify on Email
         * @param {InlineObject2} [inlineObject2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notify: async (userId: string, notifyWhatsApp?: boolean, notifyEmail?: boolean, inlineObject2?: InlineObject2, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('notify', 'userId', userId)
            const localVarPath = `/notify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEAM_NOTIFY"], configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (notifyWhatsApp !== undefined) {
                localVarQueryParameter['notifyWhatsApp'] = notifyWhatsApp;
            }

            if (notifyEmail !== undefined) {
                localVarQueryParameter['notifyEmail'] = notifyEmail;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Notify a team member
         * @param {string} userId 
         * @param {boolean} [notifyWhatsApp] Override notify on WhatsApp
         * @param {boolean} [notifyEmail] Override notify on Email
         * @param {InlineObject2} [inlineObject2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notify(userId: string, notifyWhatsApp?: boolean, notifyEmail?: boolean, inlineObject2?: InlineObject2, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notify(userId, notifyWhatsApp, notifyEmail, inlineObject2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Notify a team member
         * @param {string} userId 
         * @param {boolean} [notifyWhatsApp] Override notify on WhatsApp
         * @param {boolean} [notifyEmail] Override notify on Email
         * @param {InlineObject2} [inlineObject2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notify(userId: string, notifyWhatsApp?: boolean, notifyEmail?: boolean, inlineObject2?: InlineObject2, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.notify(userId, notifyWhatsApp, notifyEmail, inlineObject2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @summary Notify a team member
     * @param {string} userId 
     * @param {boolean} [notifyWhatsApp] Override notify on WhatsApp
     * @param {boolean} [notifyEmail] Override notify on Email
     * @param {InlineObject2} [inlineObject2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notify(userId: string, notifyWhatsApp?: boolean, notifyEmail?: boolean, inlineObject2?: InlineObject2, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notify(userId, notifyWhatsApp, notifyEmail, inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If the token is not specified, all tokens of the user are revoked
         * @summary Revoke refresh tokens
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete: async (token?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TOKENS_DELETE"], configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns in descending order of most recently used
         * @summary Fetch list of tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TOKENS_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login to ChatDaddy
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost: async (authRequest?: AuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login via an external partner
         * @param {BoutirTokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPostExternal: async (body?: BoutirTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token/external`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * If the token is not specified, all tokens of the user are revoked
         * @summary Revoke refresh tokens
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenDelete(token?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenDelete(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns in descending order of most recently used
         * @summary Fetch list of tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefreshToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login to ChatDaddy
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPost(authRequest?: AuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPost(authRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login via an external partner
         * @param {BoutirTokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPostExternal(body?: BoutirTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalTokenPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPostExternal(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         * If the token is not specified, all tokens of the user are revoked
         * @summary Revoke refresh tokens
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete(token?: string, options?: any): AxiosPromise<void> {
            return localVarFp.tokenDelete(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns in descending order of most recently used
         * @summary Fetch list of tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenGet(options?: any): AxiosPromise<Array<RefreshToken>> {
            return localVarFp.tokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login to ChatDaddy
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(authRequest?: AuthRequest, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.tokenPost(authRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login via an external partner
         * @param {BoutirTokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPostExternal(body?: BoutirTokenRequest, options?: any): AxiosPromise<ExternalTokenPostResponse> {
            return localVarFp.tokenPostExternal(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
    /**
     * If the token is not specified, all tokens of the user are revoked
     * @summary Revoke refresh tokens
     * @param {string} [token] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenDelete(token?: string, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenDelete(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns in descending order of most recently used
     * @summary Fetch list of tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenGet(options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login to ChatDaddy
     * @param {AuthRequest} [authRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenPost(authRequest?: AuthRequest, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenPost(authRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login via an external partner
     * @param {BoutirTokenRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenPostExternal(body?: BoutirTokenRequest, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenPostExternal(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OTPApi - axios parameter creator
 * @export
 */
export const OTPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate an OTP
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        otpPost: async (inlineObject1?: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OTPApi - functional programming interface
 * @export
 */
export const OTPApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OTPApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generate an OTP
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async otpPost(inlineObject1?: InlineObject1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OTP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.otpPost(inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OTPApi - factory interface
 * @export
 */
export const OTPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OTPApiFp(configuration)
    return {
        /**
         * 
         * @summary Generate an OTP
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        otpPost(inlineObject1?: InlineObject1, options?: any): AxiosPromise<OTP> {
            return localVarFp.otpPost(inlineObject1, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OTPApi - object-oriented interface
 * @export
 * @class OTPApi
 * @extends {BaseAPI}
 */
export class OTPApi extends BaseAPI {
    /**
     * 
     * @summary Generate an OTP
     * @param {InlineObject1} [inlineObject1] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTPApi
     */
    public otpPost(inlineObject1?: InlineObject1, options?: AxiosRequestConfig) {
        return OTPApiFp(this.configuration).otpPost(inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamsApi - axios parameter creator
 * @export
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch teams you have access to
         * @param {string} [q] Search by name, ID, invite code, etc.
         * @param {Array<string>} [id] Fetch specific teams by ID
         * @param {string} [userId] teams that contain this user ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeTeamMembers] Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
         * @param {boolean} [includeInviteLinks] Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
         * @param {boolean} [includeTotal] include the count of the total teams
         * @param {boolean} [includeCreator] include the creator\&#39;s data in the API result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet: async (q?: string, id?: Array<string>, userId?: string, count?: number, page?: number, includeTeamMembers?: boolean, includeInviteLinks?: boolean, includeTotal?: boolean, includeCreator?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includeTeamMembers !== undefined) {
                localVarQueryParameter['includeTeamMembers'] = includeTeamMembers;
            }

            if (includeInviteLinks !== undefined) {
                localVarQueryParameter['includeInviteLinks'] = includeInviteLinks;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['includeTotal'] = includeTotal;
            }

            if (includeCreator !== undefined) {
                localVarQueryParameter['includeCreator'] = includeCreator;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join a team
         * @param {string} id inviteLink id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsJoinInvite: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamsJoinInvite', 'id', id)
            const localVarPath = `/teams/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned 
         * @summary Update the team the access token is for
         * @param {TeamPatchRequest} [teamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsPatch: async (teamPatchRequest?: TeamPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEAM_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch teams you have access to
         * @param {string} [q] Search by name, ID, invite code, etc.
         * @param {Array<string>} [id] Fetch specific teams by ID
         * @param {string} [userId] teams that contain this user ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeTeamMembers] Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
         * @param {boolean} [includeInviteLinks] Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
         * @param {boolean} [includeTotal] include the count of the total teams
         * @param {boolean} [includeCreator] include the creator\&#39;s data in the API result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsGet(q?: string, id?: Array<string>, userId?: string, count?: number, page?: number, includeTeamMembers?: boolean, includeInviteLinks?: boolean, includeTotal?: boolean, includeCreator?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsGet(q, id, userId, count, page, includeTeamMembers, includeInviteLinks, includeTotal, includeCreator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Join a team
         * @param {string} id inviteLink id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsJoinInvite(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsJoinInvite(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned 
         * @summary Update the team the access token is for
         * @param {TeamPatchRequest} [teamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsPatch(teamPatchRequest?: TeamPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsPatch(teamPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch teams you have access to
         * @param {string} [q] Search by name, ID, invite code, etc.
         * @param {Array<string>} [id] Fetch specific teams by ID
         * @param {string} [userId] teams that contain this user ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeTeamMembers] Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
         * @param {boolean} [includeInviteLinks] Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
         * @param {boolean} [includeTotal] include the count of the total teams
         * @param {boolean} [includeCreator] include the creator\&#39;s data in the API result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet(q?: string, id?: Array<string>, userId?: string, count?: number, page?: number, includeTeamMembers?: boolean, includeInviteLinks?: boolean, includeTotal?: boolean, includeCreator?: boolean, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.teamsGet(q, id, userId, count, page, includeTeamMembers, includeInviteLinks, includeTotal, includeCreator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join a team
         * @param {string} id inviteLink id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsJoinInvite(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.teamsJoinInvite(id, options).then((request) => request(axios, basePath));
        },
        /**
         * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned 
         * @summary Update the team the access token is for
         * @param {TeamPatchRequest} [teamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsPatch(teamPatchRequest?: TeamPatchRequest, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.teamsPatch(teamPatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch teams you have access to
     * @param {string} [q] Search by name, ID, invite code, etc.
     * @param {Array<string>} [id] Fetch specific teams by ID
     * @param {string} [userId] teams that contain this user ID
     * @param {number} [count] The numbers of items to return
     * @param {number} [page] The page number
     * @param {boolean} [includeTeamMembers] Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
     * @param {boolean} [includeInviteLinks] Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
     * @param {boolean} [includeTotal] include the count of the total teams
     * @param {boolean} [includeCreator] include the creator\&#39;s data in the API result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsGet(q?: string, id?: Array<string>, userId?: string, count?: number, page?: number, includeTeamMembers?: boolean, includeInviteLinks?: boolean, includeTotal?: boolean, includeCreator?: boolean, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsGet(q, id, userId, count, page, includeTeamMembers, includeInviteLinks, includeTotal, includeCreator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join a team
     * @param {string} id inviteLink id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsJoinInvite(id: string, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsJoinInvite(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned 
     * @summary Update the team the access token is for
     * @param {TeamPatchRequest} [teamPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsPatch(teamPatchRequest?: TeamPatchRequest, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsPatch(teamPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the user specified
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDelete', 'id', id)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch users you have access to
         * @param {string} [q] Search by name, ID, email, phone etc.
         * @param {Array<string>} [id] Fetch specific users by ID
         * @param {Array<string>} [originalTeamId] Fetch specific users by original team ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeMemberships] Should include the user\&#39;s memberships
         * @param {boolean} [includeTotal] should return total count of accessible users
         * @param {Array<string>} [other] other internal query options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (q?: string, id?: Array<string>, originalTeamId?: Array<string>, count?: number, page?: number, includeMemberships?: boolean, includeTotal?: boolean, other?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (originalTeamId) {
                localVarQueryParameter['originalTeamId'] = originalTeamId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includeMemberships !== undefined) {
                localVarQueryParameter['includeMemberships'] = includeMemberships;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['includeTotal'] = includeTotal;
            }

            if (other) {
                localVarQueryParameter['other'] = other;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset user password
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPasswordPatch: async (resetPassword?: ResetPassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication otp required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the user in the access token
         * @param {string} [userId] Change the password of this user ID
         * @param {UserPatch} [userPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatch: async (userId?: string, userPatch?: UserPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["USERS_PATCH"], configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} [userCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (userCreate?: UserCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)

            // authentication otp required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the user specified
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch users you have access to
         * @param {string} [q] Search by name, ID, email, phone etc.
         * @param {Array<string>} [id] Fetch specific users by ID
         * @param {Array<string>} [originalTeamId] Fetch specific users by original team ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeMemberships] Should include the user\&#39;s memberships
         * @param {boolean} [includeTotal] should return total count of accessible users
         * @param {Array<string>} [other] other internal query options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(q?: string, id?: Array<string>, originalTeamId?: Array<string>, count?: number, page?: number, includeMemberships?: boolean, includeTotal?: boolean, other?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(q, id, originalTeamId, count, page, includeMemberships, includeTotal, other, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset user password
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPasswordPatch(resetPassword?: ResetPassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPasswordPatch(resetPassword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the user in the access token
         * @param {string} [userId] Change the password of this user ID
         * @param {UserPatch} [userPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPatch(userId?: string, userPatch?: UserPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPatch(userId, userPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} [userCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(userCreate?: UserCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(userCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Deletes the user specified
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch users you have access to
         * @param {string} [q] Search by name, ID, email, phone etc.
         * @param {Array<string>} [id] Fetch specific users by ID
         * @param {Array<string>} [originalTeamId] Fetch specific users by original team ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeMemberships] Should include the user\&#39;s memberships
         * @param {boolean} [includeTotal] should return total count of accessible users
         * @param {Array<string>} [other] other internal query options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(q?: string, id?: Array<string>, originalTeamId?: Array<string>, count?: number, page?: number, includeMemberships?: boolean, includeTotal?: boolean, other?: Array<string>, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.usersGet(q, id, originalTeamId, count, page, includeMemberships, includeTotal, other, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset user password
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPasswordPatch(resetPassword?: ResetPassword, options?: any): AxiosPromise<void> {
            return localVarFp.usersPasswordPatch(resetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the user in the access token
         * @param {string} [userId] Change the password of this user ID
         * @param {UserPatch} [userPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatch(userId?: string, userPatch?: UserPatch, options?: any): AxiosPromise<User> {
            return localVarFp.usersPatch(userId, userPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} [userCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(userCreate?: UserCreate, options?: any): AxiosPromise<User> {
            return localVarFp.usersPost(userCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Deletes the user specified
     * @summary Delete a user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDelete(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch users you have access to
     * @param {string} [q] Search by name, ID, email, phone etc.
     * @param {Array<string>} [id] Fetch specific users by ID
     * @param {Array<string>} [originalTeamId] Fetch specific users by original team ID
     * @param {number} [count] The numbers of items to return
     * @param {number} [page] The page number
     * @param {boolean} [includeMemberships] Should include the user\&#39;s memberships
     * @param {boolean} [includeTotal] should return total count of accessible users
     * @param {Array<string>} [other] other internal query options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(q?: string, id?: Array<string>, originalTeamId?: Array<string>, count?: number, page?: number, includeMemberships?: boolean, includeTotal?: boolean, other?: Array<string>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGet(q, id, originalTeamId, count, page, includeMemberships, includeTotal, other, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset user password
     * @param {ResetPassword} [resetPassword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPasswordPatch(resetPassword?: ResetPassword, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPasswordPatch(resetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the user in the access token
     * @param {string} [userId] Change the password of this user ID
     * @param {UserPatch} [userPatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPatch(userId?: string, userPatch?: UserPatch, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPatch(userId, userPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user
     * @param {UserCreate} [userCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPost(userCreate?: UserCreate, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPost(userCreate, options).then((request) => request(this.axios, this.basePath));
    }
}


